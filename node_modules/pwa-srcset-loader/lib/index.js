'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = srcSetLoader;

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mime = require('mime');

var _mime2 = _interopRequireDefault(_mime);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var DEFAULT_SIZE = 'default';

function removeResourceQuery(resource) {
  return resource.split('?')[0];
}

function splitRemainingRequest(remainingRequest) {
  var split = remainingRequest.split('!');
  var rawResource = split.pop();
  var resource = removeResourceQuery(rawResource);
  return [split, resource];
}

function rebuildRemainingRequest(loaders, resource) {
  return '-!' + [].concat(_toConsumableArray(loaders), [resource]).join('!');
}

function buildResizeLoader(rawSize) {
  var size = parseInt(rawSize, 10);

  return _url2.default.format({
    pathname: _path2.default.join(__dirname, './resize-loader'),
    query: { size: size }
  });
}

function createResizeRequest(size, existingLoaders, resource) {
  var loaders = size === DEFAULT_SIZE ? existingLoaders : [].concat(_toConsumableArray(existingLoaders), [buildResizeLoader(size)]);

  return rebuildRemainingRequest(loaders, resource);
  // const remainingRequest = rebuildRemainingRequest(loaders, resource);
  // return `require(${JSON.stringify(remainingRequest)})`;
}

function toNumber(item) {
  if (typeof item !== 'string') {
    return Number.NaN;
  }
  return Number(item);
}

async function createPlaceholderRequest(resource, size, lightweight, loaderReference) {
  var loaderOptions = {
    pathname: _path2.default.join(__dirname, './placeholder-loader'),
    query: {
      lightweight: lightweight
    }
  };

  var actualSize = toNumber(size);
  if (!Number.isNaN(actualSize)) {
    loaderOptions.query.size = actualSize;
  }
  var placeholderRequest = ['!', _url2.default.format(loaderOptions), resource].join('!');
  return new Promise(function (resolve, reject) {
    loaderReference.loadModule(placeholderRequest, function (err, source) {
      if (err) return reject(err);
      return resolve(source.replace(/module\.exports\s*=\s*/, '').replace(/;$/, ''));
    });
  });
}

async function asyncForEach(items, callback) {
  if (!Array.isArray(items)) {
    return callback(items);
  }
  for (var index = 0; index < items.length; index += 1) {
    // eslint-disable-next-line
    await callback(items[index], index, items);
  }
  return true;
}

async function buildSources(sizes, loaders, loaderReference, resource) {
  var sources = {};

  await asyncForEach(sizes, async function (size) {
    if (size != null && size !== DEFAULT_SIZE && !/\d+w/.test(size)) {
      throw new TypeError('pwa-srcset-loader: Received size "' + size + '" does not match the format "\\d+w" nor "' + DEFAULT_SIZE + '"');
    }

    var actualSize = size || DEFAULT_SIZE;
    await new Promise(function (resolve, reject) {
      loaderReference.loadModule(createResizeRequest(actualSize, loaders, resource(size)), function (err, source) {
        if (err) return reject(err);
        sources[actualSize] = source.replace(/module.exports\s*=\s*/g, '').replace(/export\s*default\s*/g, '').replace(/;$/, '');
        return resolve(source);
      });
    });
    // sources[actualSize] = createResizeRequest(actualSize, loaders, resource(size));
  });

  return sources;
}

function stringifySources(sources) {
  return '\n{\n  ' + Object.keys(sources).map(function (source) {
    return '"' + source + '": ' + sources[source];
  }).join(',\n') + '\n}\n';
}

function stringifySrcSet(sources) {
  return Object.keys(sources).map(function (size) {
    if (size === 'default') {
      return '' + sources[size];
    }

    return sources[size] + ' + " ' + size + '"';
  }).join('+","+');
}

function getSizes(sizes) {
  if (sizes == null || Array.isArray(sizes)) {
    return sizes;
  }

  if (typeof sizes === 'string') {
    return sizes.split('+');
  }

  throw new TypeError('pwa-srcset-loader: "?sizes=' + sizes + '" is invalid - expected a query like "?sizes[]=<size>&sizes[]=..." or "?sizes=<size>+<size>+...".');
}

function isLightweight(loaderQuery, resourceQuery) {
  if (loaderQuery.lightweight !== undefined) {
    return loaderQuery.lightweight;
  }

  if (resourceQuery.lightweight !== undefined) {
    return resourceQuery.lightweight;
  }

  return false;
}

async function createResourceObjectString(loaderQuery, sizes, loaders, resource, ext, placeholder, lightweight, loaderReference) {
  var contentType = _mime2.default.getType(ext);

  var transformResource = loaderQuery.transformResource || function (r, size) {
    return r + '?size=' + size;
  };

  var sources = await buildSources(sizes, loaders, loaderReference, function (size) {
    return transformResource(resource, size);
  });

  var srcSet = !lightweight ? 'srcSet: ' + stringifySrcSet(sources) + ',' : '';

  var placeholderScript = placeholder ? 'placeholder: ' + (await createPlaceholderRequest(resource, placeholder, lightweight, loaderReference)) + ',' : '';
  return '{\n    sources: ' + stringifySources(sources) + ',\n    type: ' + JSON.stringify(contentType) + ',\n    ' + srcSet + '\n    ' + placeholderScript + '\n  }';
}

function srcSetLoader(content) {
  return content;
}

srcSetLoader.pitch = function srcSetLoaderPitch(remainingRequest) {
  var _this = this;

  var loaderQuery = (0, _util.parseQuery)(this.query);
  var resourceQuery = (0, _util.parseQuery)(this.resourceQuery);
  var callback = this.async();

  var lightweight = isLightweight(loaderQuery, resourceQuery);
  if (typeof lightweight !== 'boolean') {
    throw new TypeError('pwa-srcset-loader: "?lightweight=' + lightweight + '" is invalid - expected a boolean.');
  }

  // check it isn't undefined so the resource can disable the loader configuration with `false`.
  var placeholder = resourceQuery.placeholder !== undefined ? resourceQuery.placeholder : loaderQuery.placeholder;

  // sizes can be falsy,
  // it will just return the original image along with the placeholder if requested.
  var sizes = getSizes(resourceQuery.sizes !== undefined ? resourceQuery.sizes : loaderQuery.sizes);

  // neither is requested, no need to run this loader.
  if (!placeholder && !sizes) {
    return callback(null);
  }

  var _splitRemainingReques = splitRemainingRequest(remainingRequest),
      _splitRemainingReques2 = _slicedToArray(_splitRemainingReques, 2),
      loaders = _splitRemainingReques2[0],
      resource = _splitRemainingReques2[1];

  var ext = _path2.default.extname(resource).substr(1);

  var self = this;

  return async function () {
    var outputString = await createResourceObjectString(loaderQuery, sizes, loaders, resource, ext, placeholder, lightweight, self);

    if (ext.toLowerCase() !== 'webp') {
      var wepbLoaders = loaders.slice(0);

      var fileLoader = _this.loaders.find(function (e) {
        return e.path.indexOf('file-loader') !== -1;
      });
      if (fileLoader) {
        var fileLoaderIndex = wepbLoaders.findIndex(function (e) {
          return e.indexOf('file-loader') !== -1;
        });

        var queryString = '';

        if (typeof fileLoader.options === 'string') {
          queryString = fileLoader.options;
          if (queryString.indexOf('[ext]') !== -1) {
            queryString = queryString.replace('[ext]', 'webp');
          } else {
            var nameMatch = queryString.match(/name=([^&]*)&?/);
            if (nameMatch && nameMatch.length >= 2) {
              queryString = queryString.replace(nameMatch[1], nameMatch[1] + '.webp');
            }
          }
        } else if (_typeof(fileLoader.options) === 'object') {
          var options = {};
          Object.assign(options, fileLoader.options);
          if (options && options.name) {
            if (options.name.indexOf('[ext]') !== -1) {
              options.name = options.name.replace('[ext]', 'webp');
            } else {
              options.name += '.webp';
            }
          } else {
            options.name = '[name].webp';
          }
          queryString = JSON.stringify(options);
        }
        var newFileLoader = fileLoader.path + '?' + queryString;
        wepbLoaders.splice(fileLoaderIndex, 1, newFileLoader);
        wepbLoaders.push('webp-loader');
      }
      outputString = outputString + ', ' + (await createResourceObjectString(loaderQuery, sizes, wepbLoaders, resource, 'webp', placeholder, lightweight, self));
    }
    callback(null, 'module.exports = [' + outputString + '];');
  }();
};

// webpack pitch loaders expect commonJS
module.exports.pitch = srcSetLoader.pitch;